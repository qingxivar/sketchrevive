<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SketchRevive (Fixed)</title>
  <script src="https://cdn.jsdelivr.net/npm/fabric@4.6.0/dist/fabric.min.js"></script>
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial,
        "Noto Sans", sans-serif;
      background: radial-gradient(circle at top left, #3b82f6 0, #020617 50%, #020617 100%);
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app {
      width: 100%;
      max-width: 1360px;
      margin: 24px;
      padding: 24px;
      border-radius: 24px;
      background: rgba(15, 23, 42, 0.92);
      box-shadow:
        0 24px 60px rgba(0, 0, 0, 0.6),
        0 0 0 1px rgba(148, 163, 184, 0.1);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      border-bottom: 1px dashed rgba(148, 163, 184, 0.4);
      padding-bottom: 10px;
    }

    header h1 {
      font-size: 24px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 0;
    }

    header h1 span.icon {
      display: inline-flex;
      width: 28px;
      height: 28px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #f97316, #e11d48);
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .badge {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 11px;
      background: rgba(37, 99, 235, 0.12);
      border: 1px solid rgba(59, 130, 246, 0.5);
      color: #bfdbfe;
      white-space: nowrap;
    }

    .boards {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 16px;
    }

    @media (max-width: 900px) {
      .boards {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .board {
      border-radius: 20px;
      background: radial-gradient(circle at top, rgba(30, 64, 175, 0.3), rgba(15, 23, 42, 0.96));
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .board-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .board-title {
      font-size: 15px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .board-title.dot {
      position: relative;
      padding-left: 14px;
    }

    .board-title.dot::before {
      content: "";
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 6px rgba(34, 197, 94, 0.9);
    }

    .board-subtitle {
      font-size: 12px;
      color: #9ca3af;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      padding: 8px;
      border-radius: 14px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .toolbar-group {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
    }

    .toolbar-group label {
      font-size: 11px;
      color: #9ca3af;
      white-space: nowrap;
    }

    .toolbar select,
    .toolbar input[type="color"],
    .toolbar input[type="range"],
    .toolbar button {
      font-size: 11px;
    }

    .toolbar select {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.95);
      color: #e5e7eb;
      padding: 4px 24px 4px 8px;
      appearance: none;
    }

    .toolbar input[type="color"] {
      width: 32px;
      height: 20px;
      padding: 0;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: transparent;
    }

    .toolbar input[type="range"] {
      width: 90px;
      accent-color: #60a5fa;
    }

    .toolbar button {
      border-radius: 999px;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      background: linear-gradient(90deg, #2563eb, #4f46e5);
      color: #e5e7eb;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.9);
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease;
      white-space: nowrap;
    }

    .toolbar button.secondary {
      background: rgba(30, 64, 175, 0.5);
    }

    .toolbar button.danger {
      background: linear-gradient(90deg, #f97316, #e11d48);
    }

    .toolbar button:hover {
      transform: translateY(-0.5px);
      box-shadow: 0 6px 14px rgba(15, 23, 42, 0.9);
    }

    .toolbar button span {
      font-size: 13px;
    }

    .canvas-wrapper {
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: #f3f4f6;
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.12);
      position: relative;
    }

    .canvas-wrapper canvas {
      display: block;
    }

    .canvas-footer {
      display: flex;
      justify-content: flex-end;
      font-size: 11px;
      color: #6b7280;
      margin-top: 4px;
    }

    .voice-panel {
      margin-top: 6px;
      padding: 8px;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: radial-gradient(circle at top, rgba(30, 64, 175, 0.4), rgba(15, 23, 42, 0.96));
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .voice-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: #e5e7eb;
    }

    .voice-status {
      font-size: 11px;
      color: #9ca3af;
    }

    .voice-status.active {
      color: #22c55e;
    }

    .voice-textarea {
      width: 100%;
      min-height: 90px;
      resize: vertical;
      border-radius: 12px;
      padding: 8px 10px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.95);
      color: #e5e7eb;
      font-size: 11px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
        "Courier New", monospace;
    }

    .voice-textarea:focus {
      outline: none;
      border-color: rgba(96, 165, 250, 0.9);
      box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.5);
    }

    .voice-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .voice-hint {
      font-size: 11px;
      color: #9ca3af;
    }

    .voice-button {
      padding: 9px 16px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: radial-gradient(circle at 0% 0%, #f97316, #e11d48);
      color: #e5e7eb;
      font-size: 12px;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.85),
        0 10px 24px rgba(248, 113, 113, 0.5);
      position: relative;
      overflow: hidden;
    }

    .voice-button::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 10% 0%, rgba(255, 255, 255, 0.35), transparent 55%);
      opacity: 0.7;
      pointer-events: none;
    }

    .voice-button-icon {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
    }

    .voice-button.listening {
      background: radial-gradient(circle at 0% 0%, #ef4444, #b91c1c);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.85),
        0 12px 30px rgba(239, 68, 68, 0.7);
    }

    .completion-btn {
      margin-top: 10px;
      align-self: flex-end;
      padding: 10px 18px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: radial-gradient(circle at 0% 0%, #22c55e, #16a34a);
      color: #e5e7eb;
      font-size: 13px;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.85),
        0 12px 30px rgba(22, 163, 74, 0.45);
      letter-spacing: 0.03em;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
    }

    .completion-btn::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 10% 0%, rgba(255, 255, 255, 0.3), transparent 55%);
      opacity: 0.7;
      pointer-events: none;
    }

    .completion-btn-icon {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
    }

    .completion-btn:hover {
      transform: translateY(-1px);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.85),
        0 18px 40px rgba(22, 163, 74, 0.6);
    }

    .completion-btn:active {
      transform: translateY(0);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.85),
        0 10px 24px rgba(22, 163, 74, 0.5);
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>
        <span class="icon">‚úèÔ∏è</span>
        SketchRevive
      </h1>
      <div class="badge"></div>
    </header>

    <main class="boards">
      <!-- LEFT BOARD -->
      <section class="board">
        <div class="board-header">
          <div>
            <div class="board-title dot">Partial Sketch Creation</div>
            <div class="board-subtitle"></div>
          </div>
        </div>

        <div class="toolbar">
          <div class="toolbar-group">
            <label for="left-drawing-mode-selector">Brush</label>
            <select id="left-drawing-mode-selector">
              <option value="Pencil">Pencil</option>
              <option value="Circle">Circle Brush</option>
              <option value="Spray">Spray</option>
              <option value="hline">Horizontal Pattern</option>
              <option value="vline">Vertical Pattern</option>
              <option value="square">Square Pattern</option>
              <option value="diamond">Diamond Pattern</option>
            </select>
          </div>

          <div class="toolbar-group">
            <label>Color</label>
            <input type="color" id="left-drawing-color" value="#000000" />
          </div>

          <div class="toolbar-group">
            <label>Shadow Color</label>
            <input type="color" id="left-drawing-shadow-color" value="#000000" />
          </div>

          <div class="toolbar-group">
            <label>Line Width <span id="left-line-width-label">10</span></label>
            <input
              type="range"
              id="left-drawing-line-width"
              min="1"
              max="60"
              value="10"
            />
          </div>

          <div class="toolbar-group">
            <label>Shadow Blur <span id="left-shadow-width-label">0</span></label>
            <input
              type="range"
              id="left-drawing-shadow-width"
              min="0"
              max="40"
              value="0"
            />
          </div>

          <div class="toolbar-group">
            <label>Shadow Offset <span id="left-shadow-offset-label">0</span></label>
            <input
              type="range"
              id="left-drawing-shadow-offset"
              min="0"
              max="40"
              value="0"
            />
          </div>

          <button id="left-drawing-mode">
            <span>üé®</span>
            <span>Exit Drawing Mode</span>
          </button>

          <button id="left-delete-object" class="secondary">
            <span>‚úÇÔ∏è</span>
            <span>Delete Selected</span>
          </button>

          <button id="left-clear-canvas" class="danger">
            <span>üßπ</span>
            <span>Clear Canvas</span>
          </button>
          <button id="left-upload-image" class="secondary">
            <span>üìÇ</span>
            <span>Upload Image</span>
          </button>
        </div>

        <div class="canvas-wrapper">
          <canvas id="left-canvas" width="600" height="360"></canvas>
        </div>
        <div class="canvas-footer">
          <span>Tip: select strokes and change color using the color picker.</span>
        </div>
      </section>

      <!-- RIGHT BOARD -->
      <section class="board">
        <div class="board-header">
          <div>
            <div class="board-title dot">Sketch Completion and Vectorization</div>
            <div class="board-subtitle">
          
            </div>
          </div>
        </div>
        <div class="toolbar">
          <div class="toolbar-group">
            <label for="right-drawing-mode-selector">Brush</label>
            <select id="right-drawing-mode-selector">
              <option value="Pencil">Pencil</option>
              <option value="Circle">Circle Brush</option>
              <option value="Spray">Spray</option>
              <option value="hline">Horizontal Pattern</option>
              <option value="vline">Vertical Pattern</option>
              <option value="square">Square Pattern</option>
              <option value="diamond">Diamond Pattern</option>
            </select>
          </div>

          <div class="toolbar-group">
            <label>Color</label>
            <input type="color" id="right-drawing-color" value="#000000" />
          </div>

          <div class="toolbar-group">
            <label>Shadow Color</label>
            <input type="color" id="right-drawing-shadow-color" value="#000000" />
          </div>

          <div class="toolbar-group">
            <label>Line Width <span id="right-line-width-label">10</span></label>
            <input
              type="range"
              id="right-drawing-line-width"
              min="1"
              max="60"
              value="10"
            />
          </div>

          <div class="toolbar-group">
            <label>Shadow Blur <span id="right-shadow-width-label">0</span></label>
            <input
              type="range"
              id="right-drawing-shadow-width"
              min="0"
              max="40"
              value="0"
            />
          </div>

          <div class="toolbar-group">
            <label>Shadow Offset <span id="right-shadow-offset-label">0</span></label>
            <input
              type="range"
              id="right-drawing-shadow-offset"
              min="0"
              max="40"
              value="0"
            />
          </div>

          <button id="right-drawing-mode">
            <span>üé®</span>
            <span>Exit Drawing Mode</span>
          </button>

          <button id="right-delete-object" class="secondary">
            <span>‚úÇÔ∏è</span>
            <span>Delete Selected</span>
          </button>

          <button id="right-clear-canvas" class="danger">
            <span>üßπ</span>
            <span>Clear Canvas</span>
          </button>
        </div>


        <div class="canvas-wrapper">
          <canvas id="right-canvas" width="600" height="360"></canvas>
        </div>
        <div class="canvas-footer">
          <span>Tip: select strokes, then adjust color / shadow.</span>
        </div>

        <button id="right-completion-btn" class="completion-btn">
          <span class="completion-btn-icon">‚úì</span>
          <span>Completion</span>
        </button>
      </section>

      <!-- Move the Voice Input Panel below the Right Board -->
      <div class="voice-panel">
        <div class="voice-header">
          <span>Voice Input</span>
          <span id="left-voice-status" class="voice-status">Idle</span>
        </div>

        <textarea
          id="left-voice-text"
          class="voice-textarea"
          placeholder="Speech-to-text results will appear here..."
        ></textarea>

        <div class="voice-row">
          <span class="voice-hint">
            Click to start / stop speech recognition. (Requires SpeechRecognition support)
          </span>
          <button id="left-voice-btn" class="voice-button">
            <span class="voice-button-icon">üé§</span>
            <span>Start Voice</span>
          </button>
        </div>
      </div>
    </main>
    <input
      type="file"
      id="left-upload-input"
      accept="image/*"
      style="display: none;"
    />

  </div>

  <script>
    // ÂàõÂª∫ PatternBrush ÁöÑÂ∏ÆÂä©ÂáΩÊï∞
    function createPatternBrush(canvas, mode) {
      const PatternBrush = fabric.PatternBrush;
      if (!PatternBrush) return new fabric.PencilBrush(canvas);

      const brush = new PatternBrush(canvas);

      if (mode === "hline") {
        brush.getPatternSrc = function () {
          const patternCanvas = fabric.util.createCanvasElement();
          patternCanvas.width = patternCanvas.height = 10;
          const ctx = patternCanvas.getContext("2d");
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(0, 5);
          ctx.lineTo(10, 5);
          ctx.closePath();
          ctx.stroke();
          return patternCanvas;
        };
      } else if (mode === "vline") {
        brush.getPatternSrc = function () {
          const patternCanvas = fabric.util.createCanvasElement();
          patternCanvas.width = patternCanvas.height = 10;
          const ctx = patternCanvas.getContext("2d");
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(5, 0);
          ctx.lineTo(5, 10);
          ctx.closePath();
          ctx.stroke();
          return patternCanvas;
        };
      } else if (mode === "square") {
        brush.getPatternSrc = function () {
          const squareWidth = 10,
            squareDistance = 2;
          const patternCanvas = fabric.util.createCanvasElement();
          patternCanvas.width = patternCanvas.height = squareWidth + squareDistance;
          const ctx = patternCanvas.getContext("2d");
          ctx.fillStyle = this.color;
          ctx.fillRect(0, 0, squareWidth, squareWidth);
          return patternCanvas;
        };
      } else if (mode === "diamond") {
        brush.getPatternSrc = function () {
          const squareWidth = 10,
            squareDistance = 5;
          const patternCanvas = fabric.util.createCanvasElement();
          const rect = new fabric.Rect({
            width: squareWidth,
            height: squareWidth,
            angle: 45,
            fill: this.color,
          });
          const canvasWidth = rect.getBoundingRect().width;
          patternCanvas.width = patternCanvas.height = canvasWidth + squareDistance;
          rect.set({ left: canvasWidth / 2, top: canvasWidth / 2 });
          const ctx = patternCanvas.getContext("2d");
          rect.render(ctx);
          return patternCanvas;
        };
      }

      return brush;
    }

    // ÂàùÂßãÂåñ‰∏Ä‰∏™ÁîªÊùøÔºàÈÄªËæëÂ∞ΩÈáèË∑ü‰Ω†ÊµãËØïÈÄöËøáÁöÑÁ≤æÁÆÄÁâà‰∏ÄËá¥Ôºâ
    function initBoard(prefix, canvasId) {
      const canvas = new fabric.Canvas(canvasId);
      canvas.isDrawingMode = true;
      canvas.backgroundColor = "#ffffff";
      canvas.renderAll();

      const modeSelector = document.getElementById(prefix + "-drawing-mode-selector");
      const colorInput = document.getElementById(prefix + "-drawing-color");
      const shadowColorInput = document.getElementById(prefix + "-drawing-shadow-color");
      const lineWidthInput = document.getElementById(prefix + "-drawing-line-width");
      const shadowWidthInput = document.getElementById(prefix + "-drawing-shadow-width");
      const shadowOffsetInput = document.getElementById(prefix + "-drawing-shadow-offset");
      const clearBtn = document.getElementById(prefix + "-clear-canvas");
      const delBtn = document.getElementById(prefix + "-delete-object");
      const modeBtn = document.getElementById(prefix + "-drawing-mode");
      const lineWidthLabel = document.getElementById(prefix + "-line-width-label");
      const shadowWidthLabel = document.getElementById(prefix + "-shadow-width-label");
      const shadowOffsetLabel = document.getElementById(prefix + "-shadow-offset-label");

      const modeBtnTextSpan = modeBtn.querySelector("span:last-child");
      modeBtnTextSpan.textContent = "Exit Drawing Mode";

      function applyBrushOptions() {
        const brush = canvas.freeDrawingBrush;
        if (!brush) return;
        brush.color = colorInput.value || "#000000";
        brush.width = parseInt(lineWidthInput.value, 10) || 1;

        const blur = parseInt(shadowWidthInput.value, 10) || 0;
        const offset = parseInt(shadowOffsetInput.value, 10) || 0;

        if (blur > 0 || offset !== 0) {
          brush.shadow = new fabric.Shadow({
            blur: blur,
            offsetX: offset,
            offsetY: offset,
            color: shadowColorInput.value || "#000000",
            affectStroke: true,
          });
        } else {
          brush.shadow = null;
        }
      }

      function setBrush(mode) {
        if (mode === "hline" || mode === "vline" || mode === "square" || mode === "diamond") {
          canvas.freeDrawingBrush = createPatternBrush(canvas, mode);
        } else {
          const brushClass = fabric[mode + "Brush"];
          if (brushClass) {
            canvas.freeDrawingBrush = new brushClass(canvas);
          } else {
            canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
          }
        }
        applyBrushOptions();
      }

      // ÂàùÂßã Brush
      setBrush(modeSelector.value);

      // ÂàáÊç¢ÁªòÂõæÊ®°ÂºèÔºàÂºÄ/ÂÖ≥Ëá™Áî±ÁªòÂà∂Ôºâ
      modeBtn.addEventListener("click", () => {
        canvas.isDrawingMode = !canvas.isDrawingMode;
        modeBtnTextSpan.textContent = canvas.isDrawingMode
          ? "Exit Drawing Mode"
          : "Enter Drawing Mode";
      });

      // Brush Á±ªÂûãÂàáÊç¢
      modeSelector.addEventListener("change", () => {
        setBrush(modeSelector.value);
      });

      // È¢úËâ≤ÊîπÂèò
      colorInput.addEventListener("change", () => {
        applyBrushOptions();
        const color = colorInput.value || "#000000";
        const activeObjects = canvas.getActiveObjects();
        if (activeObjects && activeObjects.length > 0) {
          activeObjects.forEach((obj) => {
            if ("stroke" in obj) {
              obj.set("stroke", color);
              // ‚≠ê ÂÖ≥ÈîÆÔºöÂêåÊ≠•Êõ¥Êñ∞‚ÄúÂéüÂßãÈ¢úËâ≤‚ÄùÔºåËøôÊ†∑ÂèñÊ∂àÈÄâ‰∏≠Êó∂Â∞±‰∏ç‰ºöËøòÂéüÊàêÊóßÁöÑÈªëËâ≤
              obj._origStrokeColor = color;
            } else if ("fill" in obj) {
              obj.set("fill", color);
            }
          });
          canvas.requestRenderAll();
        }
      });


      // Èò¥ÂΩ±È¢úËâ≤
      shadowColorInput.addEventListener("change", applyBrushOptions);

      // Á∫øÂÆΩ
      lineWidthInput.addEventListener("change", () => {
        const v = parseInt(lineWidthInput.value, 10) || 1;
        if (lineWidthLabel) lineWidthLabel.textContent = v;
        applyBrushOptions();
      });

      // Èò¥ÂΩ±Ê®°Á≥ä
      shadowWidthInput.addEventListener("change", () => {
        const v = parseInt(shadowWidthInput.value, 10) || 0;
        if (shadowWidthLabel) shadowWidthLabel.textContent = v;
        applyBrushOptions();
      });

      // Èò¥ÂΩ±ÂÅèÁßª
      shadowOffsetInput.addEventListener("change", () => {
        const v = parseInt(shadowOffsetInput.value, 10) || 0;
        if (shadowOffsetLabel) shadowOffsetLabel.textContent = v;
        applyBrushOptions();
      });

      // Ê∏ÖÁ©∫ÁîªÂ∏ÉÔºàÂè™Âú®ÁÇπÂáªÊåâÈíÆÊó∂Ëß¶ÂèëÔºå‰∏ç‰ºöÂú® mouseup Ëß¶ÂèëÔºâ
      clearBtn.addEventListener("click", () => {
        canvas.clear();
        canvas.backgroundColor = "#ffffff";
        canvas.renderAll();
      });

      // Âà†Èô§ÈÄâ‰∏≠ÂØπË±°
      delBtn.addEventListener("click", () => {
        const activeObjects = canvas.getActiveObjects();
        if (!activeObjects || activeObjects.length === 0) return;
        activeObjects.forEach((obj) => canvas.remove(obj));
        canvas.discardActiveObject();
        canvas.requestRenderAll();
      });

      // Ë∞ÉËØïÔºöÁ°ÆËÆ§ path Âú® mouseup ÂêéÁúüÁöÑË¢´Âä†Âà∞ canvas ‰∏≠
      /*
      canvas.on("path:created", (e) => {
        console.log(prefix, "path created, total objects:", canvas.getObjects().length);
      });
      */

      return canvas;
    }


    window.addEventListener("DOMContentLoaded", function () {
      const leftCanvas = initBoard("left", "left-canvas");
      const rightCanvas = initBoard("right", "right-canvas");
    
      // ‚úÖ Êñ∞Â¢ûÔºöÂ∑¶‰æß‰∏ä‰º†ÊåâÈíÆ & ÈöêËóèÊñá‰ª∂ËæìÂÖ•
      const leftUploadBtn = document.getElementById("left-upload-image");
      const leftUploadInput = document.getElementById("left-upload-input");
      // ÁÇπÂáªÊåâÈíÆÊó∂ÔºåÊâìÂºÄÊñá‰ª∂ÈÄâÊã©Ê°Ü
      if (leftUploadBtn && leftUploadInput) {
        leftUploadBtn.addEventListener("click", function () {
          leftUploadInput.click();
        });
    
        // ÈÄâÊã©Êñá‰ª∂ÂêéÔºåÊääÂõæÁâáÂä†ËΩΩÂà∞Â∑¶ÁîªÂ∏É
        leftUploadInput.addEventListener("change", function (e) {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
    
          const reader = new FileReader();
    
          reader.onload = function (event) {
            const dataUrl = event.target.result;
    
            fabric.Image.fromURL(dataUrl, function (img) {
              const canvas = leftCanvas;
    
              // ËÆ©ÂõæÁâáÊåâÊØî‰æãÁº©ÊîæÂà∞ÁîªÂ∏ÉÂ§ßÂ∞è‰ª•ÂÜÖ
              const maxWidth = canvas.width;
              const maxHeight = canvas.height;
    
              const scale = Math.min(
                maxWidth / img.width,
                maxHeight / img.height,
                1 // ‰∏çË¶ÅÊîæÂ§ßË∂ÖËøáÂéüÂßãÂ∞∫ÂØ∏
              );
    
              img.scale(scale);
    
              // Â±Ö‰∏≠ÊëÜÊîæ
              img.set({
                left: (maxWidth - img.getScaledWidth()) / 2,
                top: (maxHeight - img.getScaledHeight()) / 2,
                selectable: true,
              });
    
              // ‰Ω†ÂèØ‰ª•ÈÄâÊã©ÊòØÂê¶Ê∏ÖÁ©∫ÁîªÂ∏ÉÂÜçÊ∑ªÂä†ÂõæÁâáÔºö
              // canvas.clear();
              // canvas.backgroundColor = "#ffffff";
    
              canvas.add(img);
              canvas.requestRenderAll();
            });
          };
    
          reader.readAsDataURL(file);
    
          // ÂÖÅËÆ∏ÂÜçÊ¨°ÈÄâÊã©Âêå‰∏Ä‰∏™Êñá‰ª∂
          e.target.value = "";
        });
      }

      
  // ========= Êñ∞Â¢ûÔºöÂè≥‰æßÁîªÊùøÈÄâ‰∏≠È´ò‰∫ÆÔºàÈÄâ‰∏≠ÂèòÁ∫¢ÔºåÂèñÊ∂àÊÅ¢Â§çÂéüËâ≤Ôºâ =========
      function enableSelectionHighlight(canvas) {
        // Áªü‰∏ÄÂ§ÑÁêÜ selection:created Âíå selection:updated
        function handleSelection(e) {
          const selected = e.selected || [];
          const deselected = e.deselected || [];

          // Ë¢´ÈÄâ‰∏≠ÁöÑÂØπË±°ÔºöÊääÂéüÊù•ÁöÑÈ¢úËâ≤Â≠òËµ∑Êù•ÔºåÁÑ∂ÂêéÊîπÊàêÁ∫¢Ëâ≤
          selected.forEach((obj) => {
            if (!obj) return;
            // Âè™Â§ÑÁêÜÊúâ stroke ÁöÑÂØπË±°ÔºàPathÔºâ
            if ("stroke" in obj) {
              // Â¶ÇÊûúËøòÊ≤°‰øùÂ≠òËøáÂéüÂßãÈ¢úËâ≤ÔºåÂ∞±‰øùÂ≠ò‰∏Ä‰∏ã
              if (obj._origStrokeColor == null) {
                obj._origStrokeColor = obj.stroke || "#000000";
              }
              obj.set("stroke", "red");
            }
          });

          // Ëøô‰∏ÄËΩÆË¢´ÂèñÊ∂àÈÄâ‰∏≠ÁöÑÂØπË±°ÔºöÊÅ¢Â§çÂéüÊù•ÁöÑÈ¢úËâ≤
          deselected.forEach((obj) => {
            if (!obj) return;
            if ("stroke" in obj && obj._origStrokeColor != null) {
              obj.set("stroke", obj._origStrokeColor);
            }
          });

          canvas.requestRenderAll();
        }

        // ÂΩìÊ≤°Êúâ‰ªª‰ΩïÈÄâ‰∏≠ÂØπË±°Êó∂ÔºåÊääÊâÄÊúâ‰πãÂâçÈ´ò‰∫ÆËøáÁöÑÂØπË±°È¢úËâ≤ÊÅ¢Â§ç‰∏Ä‰∏ã
        function handleSelectionCleared(e) {
          const objects = canvas.getObjects();
          objects.forEach((obj) => {
            if ("stroke" in obj && obj._origStrokeColor != null) {
              obj.set("stroke", obj._origStrokeColor);
            }
          });
          canvas.requestRenderAll();
        }

        canvas.on("selection:created", handleSelection);
        canvas.on("selection:updated", handleSelection);
        canvas.on("selection:cleared", handleSelectionCleared);
      }

      // Âè™Âú®Âè≥‰æßÁîªÊùøÂêØÁî®È´ò‰∫ÆÊïàÊûú
      enableSelectionHighlight(rightCanvas);
    
      // ========= Êää stroke ÊñáÊú¨Ëß£ÊûêÊàêÂ§ö‰∏™ PathÔºåÂπ∂Êï¥‰ΩìÁº©ÊîæÂà∞ÁîªÂ∏ÉÈáå =========
      // Êää stroke ÊñáÊú¨Ëß£ÊûêÊàêÂ§ö‰∏™ PathÔºåÂπ∂Êï¥‰ΩìÁº©ÊîæÂà∞ÁîªÂ∏ÉÈáå
      function strokeTextToFabricPaths(text, canvas, extraScale = 1) {
        const lines = text.trim().split(/\r?\n/);

        const segments = [];
        let current = [];

        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed) {
            if (current.length > 0) {
              segments.push(current);
              current = [];
            }
            continue;
          }

          const parts = trimmed.split(/[,\s]+/).filter(Boolean);
          if (parts.length < 2) continue;

          const x = parseFloat(parts[0]);
          const y = parseFloat(parts[1]);
          if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

          current.push([x, y]);

          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
        if (current.length > 0) segments.push(current);

        if (segments.length === 0 || !isFinite(minX)) return [];

        const rawWidth = maxX - minX || 1;
        const rawHeight = maxY - minY || 1;

        const padding = 30;
        const baseScale = Math.min(
          (canvas.width - padding * 2) / rawWidth,
          (canvas.height - padding * 2) / rawHeight
        );

        const safeExtra = extraScale > 0 && isFinite(extraScale) ? extraScale : 1;
        const finalScale =
          baseScale > 0 && isFinite(baseScale) ? baseScale * safeExtra : safeExtra;

        const scaledWidth = rawWidth * finalScale;
        const scaledHeight = rawHeight * finalScale;
        const offsetX = (canvas.width - scaledWidth) / 2;
        const offsetY = (canvas.height - scaledHeight) / 2;

        const paths = segments
          .map((seg) => {
            if (seg.length === 0) return null;

            const commands = seg.map(([x, y], idx) => {
              const sx = (x - minX) * finalScale + offsetX;
              const sy = (y - minY) * finalScale + offsetY;
              return `${idx === 0 ? "M" : "L"} ${sx} ${sy}`;
            });

            const pathData = commands.join(" ");

            const path = new fabric.Path(pathData, {
              stroke: "#000000",
              fill: "",
              strokeWidth: 2,
              selectable: true,
              evented: true,
            });

            path.setCoords();
            return path;
          })
          .filter(Boolean);

        return paths;
      }

      // ========= [Êñ∞Â¢û] ‰ªé txt Êñá‰ª∂Âä†ËΩΩ stroke Âà∞Âè≥ÁîªÂ∏É =========
      // ========= [Êîπ] ‰ªé txt Êñá‰ª∂Âä†ËΩΩ stroke Âà∞Âè≥ÁîªÂ∏ÉÔºàËøΩÂä†Ôºå‰∏çÊ∏ÖÁ©∫Ôºâ =========
      async function loadStrokeFileToRightCanvas(url) {
        try {
          const res = await fetch(url);
          const text = await res.text();

          // ‰∏çÊ∏ÖÁ©∫ÁîªÂ∏ÉÔºå‰øùÁïôÂéüÊúâÂÜÖÂÆπ

          // ÈªòËÆ§ 1Ôºå‰∏çÈ¢ùÂ§ñÁº©Êîæ
          let extraScale = 1;

          // Â¶ÇÊûúÊòØÈ£ûÊú∫ËøôÂº†ÔºåÂ∞±È¢ùÂ§ñÂÜçÁº©Â∞è‰∏ÄÁÇπÔºà‰æãÂ¶Ç 0.6ÔºåËá™Â∑±ÂèØ‰ª•Ë∞ÉÔºâ
          if (url.includes("airplane_3_s12_92_binary_strokes")) {
            extraScale = 0.3;  // ÊÉ≥Êõ¥Â∞èÂ∞±ÊîπÊàê 0.5 / 0.4 Á≠â
            } else if (url.includes("000000286770_sheep_0_s17_40_generated_strokes")) {       
              extraScale = 0.5;
            } else if (url.includes("000000532285_bicycle_0_s17_85_compare_strokes")) {
              extraScale = 0.5;
          }

          const paths = strokeTextToFabricPaths(text, rightCanvas, extraScale);
          if (paths && paths.length > 0) {
            paths.forEach((p) => rightCanvas.add(p));
            rightCanvas.requestRenderAll();
          } else {
            console.warn("Ëß£Êûê stroke Êñá‰ª∂Â§±Ë¥•Ôºö", url);
          }
        } catch (err) {
          console.error("Âä†ËΩΩ stroke Êñá‰ª∂Âá∫ÈîôÔºö", url, err);
        }
      }

      // ========= [Êñ∞Â¢û] ‰∏â‰∏™Á¨îÁîªÊñá‰ª∂ÔºåÊåâÈ°∫Â∫èÔºöÈïøÈ¢àÈπø ‚Üí È∏ü ‚Üí È£ûÊú∫ =========
// ========= [Êñ∞Â¢û] ‰∏â‰∏™Á¨îÁîªÊñá‰ª∂ÔºåÊåâÈ°∫Â∫èÔºöÈïøÈ¢àÈπø ‚Üí È∏ü ‚Üí È£ûÊú∫ =========
      const strokeFiles = [
        "000000076087_giraffe_9_s20_11_generated_strokes.txt", // Á¨¨‰∏ÄÊ¨°ÁÇπÂáªÔºöÈïøÈ¢àÈπø
        "000000162682_bird_5_s8_50_generated_strokes.txt",     // Á¨¨‰∫åÊ¨°ÁÇπÂáªÔºöÈ∏ü
        "000000110310_airplane_3_s12_92_binary_strokes.txt",   // Á¨¨‰∏âÊ¨°ÁÇπÂáªÔºöÈ£ûÊú∫
        "000000214574_giraffe_1_s34_70_compare_strokes.txt",
        "000000258788_elephant_0_s14_50_generated_strokes.txt",
        "000000286770_sheep_0_s17_40_generated_strokes.txt",
        "000000532285_bicycle_0_s17_85_compare_strokes.txt",
        "000000003793_bus_8_s71_100_generated_0_strokes.txt",
        "000000086205_dog_2_s37_50_generated_0_strokes.txt",
        "000000305450_bicycle_2_s16_84_binary_strokes.txt",
        "000000326357_bird_1_s19_67_binary_strokes.txt"
      ];


      let strokeIndex = 0;

      
  // ========= [‰øÆÊîπ] Completion ÊåâÈíÆÔºö‰æùÊ¨°Âä†ËΩΩ ÈïøÈ¢àÈπø ‚Üí È∏ü ‚Üí È£ûÊú∫ =========
      const completionBtn = document.getElementById("right-completion-btn");
      completionBtn.addEventListener("click", async function () {
        const currentFile = strokeFiles[strokeIndex];

        // Ë∞ÉÁî®ÂàöÂàöÂÜôÁöÑÂä†ËΩΩÂáΩÊï∞
        await loadStrokeFileToRightCanvas(currentFile);

        // ÊåáÂêë‰∏ã‰∏Ä‰∏™Êñá‰ª∂
        strokeIndex = (strokeIndex + 1) % strokeFiles.length;
      });


      // ===== Voice input: Â∑¶‰æßËØ≠Èü≥ËæìÂÖ• =====
      const voiceBtn = document.getElementById("left-voice-btn");
      const voiceText = document.getElementById("left-voice-text");
      const voiceStatus = document.getElementById("left-voice-status");

      const SpeechRecognition =
        window.SpeechRecognition || window.webkitSpeechRecognition;

      if (!SpeechRecognition) {
        voiceStatus.textContent = "Not supported in this browser";
        voiceBtn.disabled = true;
        voiceBtn.style.opacity = 0.5;
      } else {
        const recognition = new SpeechRecognition();
        recognition.lang = "en-US"; // ÂèØÊîπ‰∏∫ "zh-CN"
        recognition.continuous = true;
        recognition.interimResults = true;

        let listening = false;
        let finalText = voiceText.value || "";

        recognition.onstart = () => {
          voiceStatus.textContent = "Listening...";
          voiceStatus.classList.add("active");
          voiceBtn.classList.add("listening");
          voiceBtn.querySelector("span:last-child").textContent = "Stop Voice";
        };

        recognition.onend = () => {
          voiceStatus.textContent = "Idle";
          voiceStatus.classList.remove("active");
          voiceBtn.classList.remove("listening");
          voiceBtn.querySelector("span:last-child").textContent = "Start Voice";
          listening = false;
        };

        recognition.onerror = (event) => {
          console.error("Speech recognition error:", event);
          voiceStatus.textContent = "Error";
          listening = false;
          voiceBtn.classList.remove("listening");
          voiceBtn.querySelector("span:last-child").textContent = "Start Voice";
        };

        recognition.onresult = (event) => {
          let interim = "";
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              finalText += transcript;
            } else {
              interim += transcript;
            }
          }
          voiceText.value = finalText + interim;
        };

        voiceBtn.addEventListener("click", (e) => {
          e.preventDefault();
          if (!listening) {
            finalText = voiceText.value || "";
            listening = true;
            try {
              recognition.start();
            } catch (err) {
              console.warn("Recognition start error:", err);
            }
          } else {
            listening = false;
            try {
              recognition.stop();
            } catch (err) {
              console.warn("Recognition stop error:", err);
            }
          }
        });
      }
    });
  </script>
</body>
</html>
